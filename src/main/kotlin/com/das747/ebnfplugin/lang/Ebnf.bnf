{
  parserClass="com.das747.ebnfplugin.lang.parser.EbnfParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Ebnf"
  psiImplClassSuffix="Impl"
  psiPackage="com.das747.ebnfplugin.lang.psi"
  psiImplPackage="com.das747.ebnfplugin.lang.psi.impl"

  elementTypeHolderClass="com.das747.ebnfplugin.lang.psi.EbnfTypes"
  elementTypeClass="com.das747.ebnfplugin.lang.psi.EbnfElementType"
  tokenTypeClass="com.das747.ebnfplugin.lang.psi.EbnfTokenType"

  tokens=[
     ASSN=":="
     SEMI=";"
     OR="|"
     CURL_L="{"
     CURL_R="}"
     SQR_L="["
     SQR_R="]"
     BRACE_L="("
     BRACE_R=")"

     space='regexp:\s+'
     comment='regexp://.*'
     number='regexp:\d+(\.\d*)?'
     id='regexp:\p{Alpha}\w*'
     string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
  ]
  extends(".*_expr")=expr
}

root ::= root_item *
private root_item ::= !<<eof>> rule ';' {pin=1 recoverWhile=rule_recover}
rule ::= rule_name ':=' definition {
  methods=["\rule_name" "\defenition"]
  pin=2
}
private rule_recover ::= !(';' | id ':=')
rule_name ::= id
definition ::= expr
expr ::= non_alternative_expr alternative_expr ?
left alternative_expr ::= ('|' non_alternative_expr) +
private non_alternative_expr ::= atom_expr concat_expr ?
left concat_expr ::= atom_expr +
private atom_expr ::= optional_expr | multiple_expr | group_expr | terminal | non_terminal
optional_expr ::= '[' expr ']'
multiple_expr ::= '{' expr '}'
private group_expr ::= '(' expr ')'
non_terminal ::= id { methods=["/id"] extends=expr}
terminal ::= string { methods=[value="/string"] extends=expr}