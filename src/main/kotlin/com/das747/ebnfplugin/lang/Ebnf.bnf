{
  parserClass="com.das747.ebnfplugin.lang.parser.EbnfParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Ebnf"
  psiImplClassSuffix="Impl"
  psiPackage="com.das747.ebnfplugin.lang.psi"
  psiImplPackage="com.das747.ebnfplugin.lang.psi.impl"

  elementTypeHolderClass="com.das747.ebnfplugin.lang.psi.EbnfTypes"
  elementTypeClass="com.das747.ebnfplugin.lang.psi.EbnfElementType"
  tokenTypeClass="com.das747.ebnfplugin.lang.psi.EbnfTokenType"

  tokens=[
     ASSN=":="
     SEMI=";"
     OR="|"
     CURL_L="{"
     CURL_R="}"
     SQR_L="["
     SQR_R="]"
     BRACE_L="("
     BRACE_R=")"

     space='regexp:\s+'
     comment='regexp://.*'
     number='regexp:\d+(\.\d*)?'
     id='regexp:\p{Alpha}\w*'
     string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
  ]
  implements(".*_expr")="com.das747.ebnfplugin.lang.psi.tree.EbnfTreeNode"
  extends(".*_expr")=expr
  mixin(".*_expr")="com.das747.ebnfplugin.lang.psi.impl.EbnfTreeNodeImplMixin"
}

root ::= root_item *
private root_item ::= !<<eof>> rule {pin=1 recoverWhile=rule_recover}
rule ::= non_terminal ':=' expr ';'{
  pin=2
  mixin="com.das747.ebnfplugin.lang.psi.impl.EbnfRuleImplMixin"
  implements="com.das747.ebnfplugin.lang.psi.EbnfNamedElement"
}
private rule_recover ::= !(';' | id ':=')
expr ::= non_alternative_expr alternative_expr ?
left alternative_expr ::= ('|' non_alternative_expr) +
private non_alternative_expr ::= atom_expr concat_expr ?
left concat_expr ::= atom_expr +
private atom_expr ::= optional_expr | multiple_expr | group_expr | terminal | non_terminal
optional_expr ::= '[' expr ']'
multiple_expr ::= '{' expr '}'
private group_expr ::= '(' expr ')'
non_terminal ::= id {
  methods=["/id"]
  extends=expr
  implements="com.das747.ebnfplugin.lang.psi.tree.EbnfLeafNode"
  mixin="com.das747.ebnfplugin.lang.psi.impl.EbnfNonTerminalImplMixin"
}
terminal ::= string {
  extends=expr
  implements="com.das747.ebnfplugin.lang.psi.tree.EbnfLeafNode"
  mixin="com.das747.ebnfplugin.lang.psi.impl.EbnfTerminalImplMixin"
}